const Router = require("express").Router();
const bcrypt = require("bcrypt");
const excel = require("excel4node");
const jwt = require("jsonwebtoken");
const fs = require("fs");
const path = require("path");
const mime = require("mime");
const xlsxFile = require("read-excel-file/node");
const querystring = require("querystring");
const { v4 } = require("uuid");

const accountModel = require("../models/account");
const itemModel = require("../models/item");
const trackedModel = require("../models/tracked");

const adminMiddleware = require("../middlewares/apiAdmin");
const authentication = require("../middlewares/apiAuthentication");
const multer = require("../services/multer");
const workbook = new excel.Workbook();

Router.get("/", adminMiddleware, (req, res, next) => {
  return res.end("Hello API, ahihi!");
});

Router.post("/login", async (req, res, next) => {
  const returnURL = querystring.escape(req.body.returnURL || process.env.BASE_URL);
  const staffId = req.body.staffId ? req.body.staffId.toUpperCase() : null;
  const password = req.body.password;

  if (!staffId) return res.json({ status: false, msg: { en: "User account is required!" } });

  if (!password) return res.json({ status: false, msg: { en: "Password is required!" } });

  const accountQuery = await accountModel.findOne({ staffId });

  if (!accountQuery) return res.json({ status: false, msg: { en: "Account does not exist!" } });

  const validPassword = bcrypt.compareSync(password, accountQuery.password);

  if (!validPassword) return res.json({ status: false, msg: { en: "Invalid password!" } });

  const jwtSignature = jwt.sign(
    {
      _id: accountQuery._id,
      staffId: accountQuery.staffId,
      role: accountQuery.role,
      fullname: `${accountQuery.firstName} ${accountQuery.lastName}`,
    },
    process.env.SECRET_KEY
  );

  res.cookie("token", jwtSignature, {
    expires: new Date(
      // Set cookie expires for 15 days
      Date.now() + 60000 * 60 * 24 * 15
    ),
    httpOnly: true,
  });

  return res.json({ status: true, msg: { en: "Login successfully!" }, redirect: querystring.unescape(returnURL) });
});

Router.post("/database/account/sync", adminMiddleware, multer.accountSync, async (req, res, next) => {
  if (!req.file) return res.json({ status: false, msg: { en: "Excel file data is required!" } });

  const rows = await xlsxFile(req.file.path);

  if (rows[0][0].toUpperCase() !== "STAFF ID")
    return res.json({
      status: false,
      msg: { en: `Invalid format excel file!` },
    });

  await accountModel.remove({});

  rows.forEach((element, index) => {
    if (index > 0) {
      if (!element[4])
        return res.json({
          status: false,
          msg: { en: `${element[1]} ${element[2]} need to be set password. At row ${index + 1} in excel file!` },
        });

      let query = { staffId: element[0].toUpperCase() };

      let update = {
        firstName: element[1],
        lastName: element[2],
        phoneNumber: element[3],
        password: bcrypt.hashSync(element[4], bcrypt.genSaltSync(10)),
        role: element[5] ? "admin" : "staff",
      };

      let options = { upsert: true, new: true, setDefaultsOnInsert: true };
      accountModel.findOneAndUpdate(query, update, options, function (error, result) {
        if (error) {
          return res.json({ status: false, msg: { en: "Failed! An error occured, please try again!" } });
        }
      });
    }
  });

  return res.json({ status: true, msg: { en: "Account data synced success!" } });
});

Router.post("/database/items/sync", adminMiddleware, multer.itemSync, async (req, res, next) => {
  if (!req.file) return res.json({ status: false, msg: { en: "Excel file data is required!" } });

  const rows = await xlsxFile(req.file.path);

  if (rows[0][0].toUpperCase() !== "BARCODE")
    return res.json({
      status: false,
      msg: { en: `Invalid format excel file!` },
    });

  rows.forEach((element, index) => {
    if (index > 0) {
      let query = { barcode: element[0] };

      let update = {
        barcode: element[0],
        itemCode: element[1],
        itemName: element[2],
        unitOfMeasure: element[3],
        active: element[4],
        department: element[5],
        supplierCode: element[6],
        supplierName: element[7],
      };

      let options = { upsert: true, new: true, setDefaultsOnInsert: true };

      itemModel.findOneAndUpdate(query, update, options, function (error, result) {
        if (error) {
          return res.json({
            status: false,
            msg: { en: `Failed! An error occured, please try again! Stopped at row ${index + 1} in excel data file.` },
          });
        }
      });
    }
  });

  return res.json({ status: true, msg: { en: "Master items data synced success!" } });
});

Router.get("/account/query/all", adminMiddleware, async (req, res, next) => {
  const accountArray = await accountModel.find({});

  return res.json({
    status: true,
    msg: { en: "Success!" },
    data: {
      total: accountArray.length,
      items:
        accountArray.length == 0
          ? []
          : accountArray.map((element) => {
              return {
                _id: element._id,
                staffId: element.staffId,
                firstName: element.firstName,
                lastName: element.lastName,
                fullName: `${element.firstName} ${element.lastName}`,
                phoneNumber: element.phoneNumber,
                role: element.role,
                deleted: element.deleted,
                createdAt: element.createdAt,
                updatedAt: element.updatedAt,
              };
            }),
    },
  });
});

Router.get("/items/query/all", authentication, async (req, res, next) => {
  const itemArray = await itemModel.find({});

  return res.json({
    status: true,
    msg: { en: "Success!" },
    data: {
      total: itemArray.length,
      items:
        itemArray.length == 0
          ? []
          : itemArray.map((element) => {
              return {
                _id: element._id,
                barcode: element.barcode,
                itemCode: element.itemCode,
                itemName: element.itemName,
                unitOfMeasure: element.unitOfMeasure,
                active: element.active,
                department: element.department,
                supplierCode: element.supplierCode,
                supplierName: element.supplierName,
                deleted: element.deleted,
                createdAt: element.createdAt,
                updatedAt: element.updatedAt,
              };
            }),
    },
  });
});

Router.get("/account/query/:id", adminMiddleware, async (req, res, next) => {
  const accountPayload = await accountModel.findOne({ staffId: req.params.id.toLocaleUpperCase() });

  if (!accountPayload) {
    return res.json({ status: false, msg: { en: "Account does not exist!" } });
  }

  return res.json({
    status: true,
    msg: { en: "Success!" },
    data: {
      _id: accountPayload._id,
      staffId: accountPayload.staffId,
      firstName: accountPayload.firstName,
      lastName: accountPayload.lastName,
      fullName: `${accountPayload.firstName} ${accountPayload.lastName}`,
      phoneNumber: accountPayload.phoneNumber,
      role: accountPayload.role,
      deleted: accountPayload.deleted,
      createdAt: accountPayload.createdAt,
      updatedAt: accountPayload.updatedAt,
    },
  });
});

Router.get("/items/query/:id", authentication, async (req, res, next) => {
  const itemPayload = await itemModel.findOne({ barcode: req.params.id });

  if (!itemPayload) {
    return res.json({ status: false, msg: { en: "Item not found!" } });
  }

  return res.json({
    status: true,
    msg: { en: "Success!" },
    data: {
      _id: itemPayload._id,
      barcode: itemPayload.barcode,
      itemCode: itemPayload.itemCode,
      itemName: itemPayload.itemName,
      unitOfMeasure: itemPayload.unitOfMeasure,
      active: itemPayload.active,
      department: itemPayload.department,
      supplierCode: itemPayload.supplierCode,
      supplierName: itemPayload.supplierName,
      deleted: itemPayload.deleted,
      createdAt: itemPayload.createdAt,
      updatedAt: itemPayload.updatedAt,
    },
  });
});

Router.post("/items/tracking", async function (req, res, next) {
  const validCondition = req.body.staffId && req.body.barcode && req.body.exp && req.body.qty;
  if (!validCondition) return res.status(200).json({ status: false, code: 200, msg: { en: "Please submit your form data!" } });

  const userFoundPayload = await accountModel.findOne({ staffId: req.body.staffId.toUpperCase() });
  if (!userFoundPayload) return res.status(401).json({ status: false, code: 401, msg: { en: "Invalid staff ID!" } });

  const existedTracked = await trackedModel.findOne({ barcode: req.body.barcode, staffId: req.body.staffId.toUpperCase(), exp: req.body.exp });

  console.log(existedTracked);

  if (existedTracked && existedTracked.exp == req.body.exp) {
    if (parseInt(req.body.qty) === 0) {
      await trackedModel.remove({ barcode: req.body.barcode, staffId: req.body.staffId.toUpperCase(), exp: req.body.exp });
      return res.status(200).json({ status: true, code: 200, msg: { en: "OK and deleted!" } });
    } else {
      await trackedModel.updateOne(
        { barcode: req.body.barcode, staffId: req.body.staffId.toUpperCase(), exp: req.body.exp },
        { qty: parseInt(existedTracked.qty) + parseInt(req.body.qty) }
      );
      return res.status(200).json({ status: true, code: 200, msg: { en: "OK and updated!" } });
    }
  }

  const itemDetail = await itemModel.findOne({ barcode: req.body.barcode });

  await trackedModel.create({
    staffId: req.body.staffId.toUpperCase(),
    barcode: req.body.barcode,
    product_name: itemDetail.itemName,
    exp: req.body.exp,
    qty: req.body.qty,
  });

  return res.status(200).json({ status: true, code: 200, msg: { en: "OK and new one" } });
});

Router.post("/items/tracking-edit", async function (req, res, next) {
  const validCondition = req.body.staffId && req.body.barcode && req.body.exp && req.body.qty;
  if (!validCondition) return res.status(200).json({ status: false, code: 200, msg: { en: "Please submit your form data!" } });

  const userFoundPayload = await accountModel.findOne({ staffId: req.body.staffId.toUpperCase() });
  if (!userFoundPayload) return res.status(401).json({ status: false, code: 401, msg: { en: "Invalid staff ID!" } });

  const existedTracked = await trackedModel.findOne({ barcode: req.body.barcode, staffId: req.body.staffId.toUpperCase(), exp: req.body.exp });

  console.log(existedTracked);

  if (existedTracked && existedTracked.exp == req.body.exp) {
    await trackedModel.updateOne(
      { barcode: req.body.barcode, staffId: req.body.staffId.toUpperCase(), exp: req.body.exp },
      { qty: parseInt(req.body.qty) }
    );
    return res.status(200).json({ status: true, code: 200, msg: { en: "OK and updated!" } });
  }

  return res.status(200).json({ status: false, code: 200, msg: { en: "Failed!" } });
});

Router.get("/items/tracking-query-all/:staffId", async function (req, res, next) {
  if (!req.params.staffId) return res.status(401).json({ status: false, code: 401, msg: { en: "Invalid staff ID!" } });

  const trackeds = await trackedModel.find({ staffId: req.params.staffId.toUpperCase() });

  if (trackeds.length > 0) return res.status(200).json({ status: true, code: 200, msg: { en: "Success!" }, data: trackeds });

  return res.status(200).json({ status: true, code: 200, msg: { en: "Empty data list!" }, data: [] });
});

Router.get("/items/tracking-query-all", async function (req, res, next) {
  const trackeds = await trackedModel.find({});

  if (trackeds.length > 0) return res.status(200).json({ status: true, code: 200, msg: { en: "Success!" }, data: trackeds });

  return res.status(200).json({ status: true, code: 200, msg: { en: "Empty data list!" }, data: [] });
});

Router.get("/items/tracking-reset", adminMiddleware, async function (req, res, next) {
  const confirm = req.query.confirm || null;
  if (!confirm || confirm.toLocaleLowerCase() != "true") return res.status(200).json({ status: false, code: 200, msg: { en: "Failed to reset!" } });
  await trackedModel.remove({});
  return res.status(200).json({ status: true, code: 200, msg: { en: "Reset successfully!" } });
});

Router.get("/excel-export-data/download/lastest", adminMiddleware, async function (req, res, next) {
  const id = v4();
  try {
    var dir = path.resolve(__dirname, "../", "data");
    !fs.existsSync(dir) ? fs.mkdirSync(dir) : null;
    const worksheet = workbook.addWorksheet("Master");
    const titleStyle = workbook.createStyle({
      font: {
        color: "#000000",
        size: 12,
        bold: true,
      },
    });
    const normalStyle = workbook.createStyle({
      font: {
        color: "#000000",
        size: 12,
      },
    });

    worksheet.cell(1, 1).string("Staff ID").style(titleStyle);
    worksheet.cell(1, 2).string("Barcode").style(titleStyle);
    worksheet.cell(1, 3).string("Item name").style(titleStyle);
    worksheet.cell(1, 4).string("Exp").style(titleStyle);
    worksheet.cell(1, 5).string("Qty").style(titleStyle);

    await trackedModel.find({}).then((list) => {
      if (list.length > 0) {
        list.forEach((item, index) => {
          console.log(index + item.product_name);
          worksheet
            .cell(index + 2, 1)
            .string(item.staffId)
            .style(normalStyle);
          worksheet
            .cell(index + 2, 2)
            .string(item.barcode)
            .style(normalStyle);
          worksheet
            .cell(index + 2, 3)
            .string(item.product_name)
            .style(normalStyle);
          worksheet
            .cell(index + 2, 4)
            .string(item.exp)
            .style(normalStyle);
          worksheet
            .cell(index + 2, 5)
            .string(item.qty)
            .style(normalStyle);
        });
      } else {
        worksheet.cell(2, 1).string("No items").style(normalStyle);
      }
    });

    const exportedFile = dir + `/exported_${id}.xlsx`;
    workbook.write(exportedFile, (err, stats) => {
      if (!err) {
        var filename = path.basename(exportedFile);
        var mimetype = mime.lookup(exportedFile);
        res.setHeader("Content-disposition", "attachment; filename=" + filename);
        res.setHeader("Content-type", mimetype);
        var filestream = fs.createReadStream(exportedFile);
        filestream.pipe(res);
      } else {
        res.end("An error occured, please refesh this page!");
      }
    });
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      status: false,
      code: 500,
      msg: {
        en: "An error occured on server!",
        vn: "Server có lỗi xảy ra!",
        err: error.message,
      },
    });
  }
});

module.exports = Router;
